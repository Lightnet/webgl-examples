<!DOCTYPE html>
<html lang="en">
<head>
<title>THREE.SimpleDatGui Demo</title>
<meta charset="utf-8">
<style>
body {
	margin: 0px;
	background-color: #8258FA;
	overflow: hidden;
}

.absoluteTitle {
	position: absolute;
	bottom: 0px;
	left: 0px;
	color: #000;
	font-family: Arial;
	font-size: 10pt;
	text-align: left;
	padding-left: 10px;
	padding-right: 10px;
	padding-bottom: 10px;
}
</style>
</head>
<body>
<script src="./lib/three.min.js"></script>
<script src="./lib/TrackballControls.js"></script>
<script src="./lib/stats.min.js"></script>
<!-- 
     Imports for THREE.SimpleDatGui | START -->
<script src="./lib/helvetiker_regular.typeface.js"></script>
<script src="./THREE.SimpleDatGui.js"></script>
<!-- Imports for THREE.SimpleDatGui | END   
-->
<div class="absoluteTitle">THREE.SimpleDatGui - rendering with pure WebGL based on three.js without any other 3rd party libraries. You may find the source code in <a href="https://github.com/MarkusSprunck/webgl-examples">GitHub</a>.
</div>
<script>
    var camera, stats, scene, renderer, mesh, gui, trackbarControl, container;

    // CREATE OPTIONS FOR GUI | START
    function myOptionsDefinition() {
        "use strict";
        return {
                    RENDER_TEXT: "Hello World!",
                    OPACITY_AUTOMATIC: true,
                    ROTATION_SPEED: 10,
                    OPACITY: 100
        };
    }
    var myOptions = myOptionsDefinition();
    // CREATE OPTIONS FOR GUI | END

    init();
    animate();

    function init() {

        container = document.createElement( 'div' );
		document.body.appendChild( container );
		
        renderer = new THREE.WebGLRenderer({
            antialias: true
        });

        renderer.setClearColor(0x8258FA);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 10000);
        camera.position.z = 400;

        scene = new THREE.Scene();

        var blueLight = new THREE.PointLight(0xAAAAFF);
        blueLight.position.set(-100, 100, camera.position.z);
        scene.add(blueLight);

        var yellowLight = new THREE.PointLight(0xFFFFAA);
        yellowLight.position.set(-400, 400, -camera.position.z);
        scene.add(yellowLight);

        trackbarControl = new THREE.TrackballControls(camera, renderer.domElement);
        trackbarControl.target.set(0, 0, 0);
        trackbarControl.rotateSpeed = 1.0;
        trackbarControl.zoomSpeed = 1.2;
        trackbarControl.panSpeed = 0.8;
        trackbarControl.staticMoving = false;
        trackbarControl.dynamicDampingFactor = 0.15;

        addRotatingText(scene, myOptions.RENDER_TEXT);

        var objFunctions = {
            RESET_EVENT: function() {
                camera.position.x = 0;
                camera.position.z = 500;
                camera.position.y = 0;
                camera.rotation.x = 0;
                camera.rotation.y = 0;
                camera.rotation.z = 0;
                camera.lookAt(new THREE.Vector3(0, 0, 0));
                trackbarControl.reset();
            }
        };

        // CREATE GUI | START
        gui = new THREE.SimpleDatGui(scene, camera, renderer, {
                    width: 250,
                    position: new THREE.Vector3(-150, 100, 150)
        });

        var folder1 = gui.addFolder("General Options");
        folder1.add(objFunctions, 'RESET_EVENT').name('Reset Position');
        folder1.add(myOptions, 'ROTATION_SPEED', 0, 40).step(5).name('Rotation Speed');
        folder1.add(myOptions, 'RENDER_TEXT').name('Render Text').onChange(function(value) {
            addRotatingText(scene, myOptions.RENDER_TEXT);
        });
        folder1.open();

        var folder2 = gui.addFolder("Opacity Options");
        folder2.add(myOptions, 'OPACITY_AUTOMATIC').name('Run Animation');
        folder2.add(myOptions, 'OPACITY', 10, 100).step(10).name('Value');
        folder2.open();
        // CREATE GUI | END

        window.addEventListener('resize', onWindowResize, false);

        // RIGHT MOUSE CLICK WILL RESET POSITION
        renderer.domElement.addEventListener('mousedown', function(event) {
            if (event.which == 3) {
                objFunctions.RESET_EVENT();
            }
        });
        
        stats = new Stats();
		stats.domElement.style.position = 'absolute';
		stats.domElement.style.top = '0px';
		stats.domElement.style.zIndex = 100;
		container.appendChild( stats.domElement );
    }

    function addRotatingText(scene, value) {
        var oldRotationX = 0;
        if (typeof mesh !== "undefined") {
            oldRotationX = mesh.rotation.x;
            scene.remove(mesh);
        }
        var geometry = new THREE.TextGeometry(myOptions.RENDER_TEXT, {
                    height: 20.0,
                    size: 160.0,
                    bevelSize: 1.5,
                    bevelThickness: 1.2,
                    bevelSegments: 4,
                    bevelEnabled: true
        });
        var material = new THREE.MeshPhongMaterial({
            color: 0xdddddd
        });
        mesh = new THREE.Mesh(geometry, material);
        mesh.rotation.x = oldRotationX;
        geometry.computeBoundingBox();
        geometry.textWidth = geometry.boundingBox.max.x - geometry.boundingBox.min.x;
        mesh.translateX(-geometry.textWidth / 2);
        scene.add(mesh);
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
        requestAnimationFrame(animate);

        if (myOptions.OPACITY_AUTOMATIC) {
            myOptions.OPACITY = 10 * Math.round(10 * (2 + Math.sin(mesh.rotation.x)) / 3);
        }

        // UPDATE | START      
        gui.setOpacity(myOptions.OPACITY);
        gui.update();
        // UPDATE | END

        mesh.rotation.x += 0.0005 * myOptions.ROTATION_SPEED;

        trackbarControl.update();
        stats.update();

        renderer.render(scene, camera);
    }
</script>
</body>
</html>
