<!DOCTYPE html>
<html lang="en">
<head>
<title>THREE.SimpleDatGui Demo</title>
<meta charset="utf-8">
<style>
body {
	margin: 0px;
	background-color: #000;
	overflow: hidden;
}

.absoluteTitle {
	position: absolute;
	bottom: 0px;
	left: 0px;
	color: #999;
	font-family: Arial;
	font-size: 9pt;
	text-align: left;
	padding-left: 10px;
	padding-right: 10px;
	padding-bottom: 15px;
}
</style>
</head>
<body>
<script src="./lib/three.min.js"></script>
<script src="./lib/TrackballControls.js"></script>
<script src="./lib/stats.min.js"></script>
<!-- Imports for THREE.SimpleDatGui | START -->
<script src="./lib/helvetiker_regular.typeface.js"></script>
<script src="./lib/gentilis_regular.typeface.js"></script>
<script src="./lib/optimer_regular.typeface.js"></script>
<script src="./THREE.SimpleDatGui.js"></script>
<!-- Imports for THREE.SimpleDatGui | END   -->
<div class="absoluteTitle">THREE.SimpleDatGui is rendered in WebGL based on three.js without any other 3rd party library. You may use your mouse wheel to zoom and the left mouse button to rotate the scene. A click with the right mouse button resets the position of the scene. Read more <a href="http://www.sw-engineering-candies.com/blog-1/three-simpledatgui-a-simple-user-interface-for-webgl-with-the-look-feel-of-dat-gui">here</a>.
</div>
<script>
    // CREATE OPTIONS WITH DEFAULT VALUES
    function myOptionsDefinition() {
        "use strict";
        return {
                    RENDER_TEXT: "Hello World!",
                    OPACITY_AUTOMATIC: false,
                    ROTATION_SPEED: 2.5,
                    FONT_SIZE: 120,
                    ROTATION_X_AXIS: false,
                    OPACITY: 100,
                    FONT_NAME: "Gentilis",
                    SHOW_STATS: false
        };
    }
    var myOptions = myOptionsDefinition();

    var camera, cameraHUD, stats, scene, sceneHUD, renderer, mesh, gui, trackbarControl, container, hemiLight;
    var opacityAnimationFactor = 0;

    var HUDBorderTop = 10;
    var HUDBorderLeft = 10;
    var HUDModus = true;

    init();
    animate();

    function init() {
        "use strict";

        // Prepare scene 

        renderer = new THREE.WebGLRenderer({
            antialias: true
        });
        renderer.setClearColor(0x444444);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.autoClear = false;
        document.body.appendChild(renderer.domElement);

        camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 10000);
        camera.position.x = 0;
        camera.position.y = 0;
        camera.position.z = 560;
        camera.rotation.x = 0;
        camera.rotation.y = 0;
        camera.rotation.z = 0;
        camera.lookAt(new THREE.Vector3(0, 0, 0));

        var width = window.innerWidth;
        var height = window.innerHeight;

        if (HUDModus) {
            cameraHUD = new THREE.OrthographicCamera(-width / 2, width / 2, height / 2, -height / 2, 1, 10);
            cameraHUD.position.z = 10;
            cameraHUD.lookAt(new THREE.Vector3(0, 0, 0));
        } else {
            cameraHUD = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 10000); // new THREE.OrthographicCamera(-width / 2, width / 2, height / 2, -height / 2, 1, 10);
            cameraHUD.position.z = 500;
            cameraHUD.lookAt(new THREE.Vector3(0, 0, 0));
        }

        sceneHUD = new THREE.Scene();

        scene = new THREE.Scene();

        // Add lights

        var yellowLight = new THREE.PointLight(0xFFFF00);
        yellowLight.position.set(-800, 800, 2 * camera.position.z);
        scene.add(yellowLight);

        var hemiLight = new THREE.HemisphereLight(0xffffff, 0xffffff, 0.6);
        hemiLight.color.setHSL(0.6, 1, 0.6);
        hemiLight.groundColor.setHSL(0.095, 1, 0.75);
        hemiLight.position.set(0, 800, 0);
        scene.add(hemiLight);

        // Add content 

        addOrUpdateRotatingText(scene, myOptions.RENDER_TEXT);

        var objFunctions = {
            RESET_EVENT: function() {
                trackbarControl.reset();
                camera.position.x = 0;
                camera.position.y = 0;
                camera.position.z = 400;
                camera.rotation.x = 0;
                camera.rotation.y = 0;
                camera.rotation.z = 0;
                camera.lookAt(new THREE.Vector3(0, 0, 0));
            }
        };

        // Add GUI
        var guiWidth = 300;
        gui = new THREE.SimpleDatGui({
                    scene: sceneHUD,
                    camera: cameraHUD,
                    renderer: renderer,
                    width: guiWidth,
                    scale: 2.0,
                    position: new THREE.Vector3(HUDBorderLeft - width / 2, height / 2 - HUDBorderTop, 1)
        });
        gui.add(objFunctions, 'RESET_EVENT').name('Reset Position');
        gui.add(myOptions, 'RENDER_TEXT').name('Render Text').onChange(function(value) {
            addOrUpdateRotatingText(scene, myOptions.RENDER_TEXT);
        });
        var folder1 = gui.addFolder("Rendering");
        folder1.add(myOptions, 'SHOW_STATS').name('Show Stats');
        folder1.add(myOptions, 'ROTATION_X_AXIS').name('Rotation Active');
        folder1.add(myOptions, 'ROTATION_SPEED', -5, 5).step(0.5).name('Rotation Speed');
        folder1.add(myOptions, 'FONT_SIZE', {
                    Minimal: 20,
                    Small: 50,
                    Medium: 100,
                    Large: 120,
                    Huge: 200
        }).name('Font Size').onChange(function(value) {
            addOrUpdateRotatingText(scene, myOptions.RENDER_TEXT);
        });
        folder1.add(myOptions, 'FONT_NAME', ['Helvetiker', 'Gentilis', 'Optimer']).name('Font Type').onChange(
                    function(value) {
                        addOrUpdateRotatingText(scene, myOptions.RENDER_TEXT);
                    });
        folder1.open();
        var folder2 = gui.addFolder("Opacity");
        folder2.add(myOptions, 'OPACITY_AUTOMATIC').name('Run Animation');
        folder2.add(myOptions, 'OPACITY', 10, 100).step(10).name('Value');
        gui.close();

        // Add event listeners
        window.addEventListener('resize', onWindowResize, false);

        renderer.domElement.addEventListener('mousedown', function(event) {
            if (event.which == 3) {
                objFunctions.RESET_EVENT(); // RIGHT MOUSE CLICK WILL RESET POSITION                
            }
        });

        trackbarControl = new THREE.TrackballControls(camera, renderer.domElement);
        trackbarControl.target.set(0, 0, 0);
        trackbarControl.rotateSpeed = 1.0;
        trackbarControl.zoomSpeed = 1.2;
        trackbarControl.panSpeed = 0.8;
        trackbarControl.staticMoving = false;
        trackbarControl.dynamicDampingFactor = 0.15;

        // Add performance display

        stats = new Stats();
        stats.domElement.style.position = 'absolute';
        stats.domElement.style.top = '' + HUDBorderTop + 'px';
        stats.domElement.style.right = '10px';
        stats.domElement.style.zIndex = 100;
        document.body.appendChild(stats.domElement);

    }

    function onWindowResize() {
        "use strict";

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);

        if (HUDModus) {
            cameraHUD.left = -window.innerWidth / 2;
            cameraHUD.right = window.innerWidth / 2;
            cameraHUD.top = window.innerHeight / 2;
            cameraHUD.bottom = -window.innerHeight / 2;
            cameraHUD.updateProjectionMatrix();

            // Udpate position of GUI
            gui.update({
                position: new THREE.Vector3(HUDBorderLeft - window.innerWidth / 2, window.innerHeight / 2
                            - HUDBorderTop, 1)
            });
        } else {
            cameraHUD.aspect = window.innerWidth / window.innerHeight;
            cameraHUD.updateProjectionMatrix();
        }
    }

    function animate() {
        "use strict";

        requestAnimationFrame(animate);

        if (myOptions.OPACITY_AUTOMATIC) {
            opacityAnimationFactor += 0.005;
            myOptions.OPACITY = 10 * Math.round(2 + 4 * (1 + Math.sin(opacityAnimationFactor)));
        }

        // UPDATE | START      
        gui.setOpacity(myOptions.OPACITY);
        gui.update();
        // UPDATE | END

        if (myOptions.ROTATION_X_AXIS) {
            mesh.rotation.x += 0.005 * myOptions.ROTATION_SPEED;
        }

        trackbarControl.update();
        stats.domElement.hidden = !myOptions.SHOW_STATS;
        if (myOptions.SHOW_STATS) {
            stats.update();
        }

        renderer.clear();
        renderer.render(scene, camera);
        renderer.render(sceneHUD, cameraHUD);
    }

    function addOrUpdateRotatingText(scene, value) {
        "use strict";

        var oldRotationX = 0;
        var oldRotationY = 0;

        if (typeof mesh !== "undefined") {
            oldRotationX = mesh.rotation.x;
            oldRotationY = mesh.rotation.y;
            scene.remove(mesh);
        }

        if (typeof myOptions.FONT_NAME === "undefined") {
            console.log("myOptions.FONT_NAME === undefined");
        }

        var geometry = new THREE.TextGeometry(myOptions.RENDER_TEXT,
                    {
                                height: myOptions.FONT_SIZE / 10,
                                size: myOptions.FONT_SIZE,
                                font: (typeof myOptions.FONT_NAME !== "undefined") ? myOptions.FONT_NAME.toLowerCase()
                                            : "gentilis"
                    });
        var material = new THREE.MeshPhongMaterial({
            color: 0xdddddd
        });
        mesh = new THREE.Mesh(geometry, material);

        mesh.rotation.x = oldRotationX;
        mesh.rotation.y = oldRotationY;

        geometry.computeBoundingBox();
        geometry.textWidth = geometry.boundingBox.max.x - geometry.boundingBox.min.x;
        mesh.translateX(-geometry.textWidth / 2);

        scene.add(mesh);
    }
</script>
</body>
</html>
