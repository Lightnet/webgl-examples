<!DOCTYPE html>
<html lang="en">
<head>
<title>THREE.SimpleDatGui Demo</title>
<meta charset="utf-8">
<style>
body {
	margin: 0px;
	background-color: #000;
	overflow: hidden;
}

.absoluteTitle {
	position: absolute;
	bottom: 0px;
	left: 0px;
	color: #999;
	font-family: Arial;
	font-size: 9pt;
	text-align: left;
	padding-left: 10px;
	padding-right: 10px;
	padding-bottom: 15px;
}
</style>
</head>
<body>
<script src="./lib/three.min.js"></script>
<script src="./lib/TrackballControls.js"></script>
<script src="./lib/stats.min.js"></script>
<!-- Imports for THREE.SimpleDatGui | START -->
<script src="./lib/helvetiker_regular.typeface.js"></script>
<script src="./lib/gentilis_regular.typeface.js"></script>
<script src="./lib/optimer_regular.typeface.js"></script>
<script src="./THREE.SimpleDatGui.js"></script>
<!-- Imports for THREE.SimpleDatGui | END   -->
<div class="absoluteTitle">THREE.SimpleDatGui is rendered in WebGL based on three.js without any other 3rd party library. You may use your mouse wheel to zoom and the left mouse button to rotate the scene. A click with the right mouse button resets the position of the scene. Read more <a href="http://www.sw-engineering-candies.com/blog-1/three-simpledatgui-a-simple-user-interface-for-webgl-with-the-look-feel-of-dat-gui">here</a>.
</div>
<script>
    // CREATE OPTIONS WITH DEFAULT VALUES
    function myOptionsDefinition() {
        "use strict";
        return {
                    RENDER_TEXT: "Hello!",
                    OPACITY_AUTOMATIC: false,
                    ROTATION_SPEED: 2.5,
                    FONT_SIZE: 150,
                    ROTATION_X_AXIS: true,
                    ROTATION_Y_AXIS: false,
                    OPACITY: 100,
                    FONT_NAME: "gentilis",
                    SHOW_STATS: false
        };
    }
    var myOptions = myOptionsDefinition();

    var camera, stats, scene, renderer, mesh, gui, trackbarControl, container, hemiLight;
    var opacityAnimationFactor = 0;

    init();
    animate();

    function init() {
        "use strict";

        // Prepare scene 

        renderer = new THREE.WebGLRenderer({
            antialias: true
        });
        renderer.setClearColor(0x444444);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 10000);
        camera.position.x = 0;
        camera.position.y = 0;
        camera.position.z = 400;
        camera.rotation.x = 0;
        camera.rotation.y = 0;
        camera.rotation.z = 0;
        camera.lookAt(new THREE.Vector3(0, 0, 0));

        scene = new THREE.Scene();

        // Add lights

        var yellowLight = new THREE.PointLight(0xFFFF00);
        yellowLight.position.set(-800, 800, 2 * camera.position.z);
        scene.add(yellowLight);

        var hemiLight = new THREE.HemisphereLight(0xffffff, 0xffffff, 0.6);
        hemiLight.color.setHSL(0.6, 1, 0.6);
        hemiLight.groundColor.setHSL(0.095, 1, 0.75);
        hemiLight.position.set(0, 800, 0);
        scene.add(hemiLight);

        // Add content 

        addOrUpdateRotatingText(scene, myOptions.RENDER_TEXT);

        var objFunctions = {
            RESET_EVENT: function() {
                trackbarControl.reset();
                camera.position.x = 0;
                camera.position.y = 0;
                camera.position.z = 400;
                camera.rotation.x = 0;
                camera.rotation.y = 0;
                camera.rotation.z = 0;
                camera.lookAt(new THREE.Vector3(0, 0, 0));
            }
        };

        // Add GUI

        gui = new THREE.SimpleDatGui({
                    scene: scene,
                    camera: camera,
                    renderer: renderer,
                    width: 280,
                    position: new THREE.Vector3(-140, 130, 140)
        });

        gui.add(objFunctions, 'RESET_EVENT').name('Reset Position of User Interface');
        gui.add(myOptions, 'RENDER_TEXT').name('Render Text').onChange(function(value) {
            addOrUpdateRotatingText(scene, myOptions.RENDER_TEXT);
        });
        var folder1 = gui.addFolder("General Options");

        folder1.add(myOptions, 'ROTATION_X_AXIS').name('Rotate X');
        folder1.add(myOptions, 'ROTATION_Y_AXIS').name('Rotate Y');
        folder1.add(myOptions, 'ROTATION_SPEED', -5, 5).step(0.5).name('Rotation Speed');
        folder1.add(myOptions, 'FONT_SIZE', 50, 250).step(25).name('Render Font Size').onChange(function(value) {
            addOrUpdateRotatingText(scene, myOptions.RENDER_TEXT);
        });
        folder1.add(myOptions, 'SHOW_STATS').name('Show Stats');
        folder1.add(myOptions, 'FONT_NAME', ['helvetiker', 'gentilis', 'optimer']).name('Font').onChange(
                    function(value) {
                        addOrUpdateRotatingText(scene, myOptions.RENDER_TEXT);
                    });
        folder1.open();

        var folder2 = gui.addFolder("Opacity Options");
        folder2.add(myOptions, 'OPACITY_AUTOMATIC').name('Run Animation');
        folder2.add(myOptions, 'OPACITY', 10, 100).step(10).name('Value');
        folder2.open();

        // Add event listeners
        window.addEventListener('resize', onWindowResize, false);

        renderer.domElement.addEventListener('mousedown', function(event) {
            if (event.which == 3) {
                objFunctions.RESET_EVENT(); // RIGHT MOUSE CLICK WILL RESET POSITION                
            }
        });

        trackbarControl = new THREE.TrackballControls(camera, renderer.domElement);
        trackbarControl.target.set(0, 0, 0);
        trackbarControl.rotateSpeed = 1.0;
        trackbarControl.zoomSpeed = 1.2;
        trackbarControl.panSpeed = 0.8;
        trackbarControl.staticMoving = false;
        trackbarControl.dynamicDampingFactor = 0.15;

        // Add performance display

        stats = new Stats();
        stats.domElement.style.position = 'absolute';
        stats.domElement.style.top = '10px';
        stats.domElement.style.right = '10px';
        stats.domElement.style.zIndex = 100;
        document.body.appendChild(stats.domElement);

    }

    function onWindowResize() {
        "use strict";

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
        "use strict";

        requestAnimationFrame(animate);

        if (myOptions.OPACITY_AUTOMATIC) {
            opacityAnimationFactor += 0.005;
            myOptions.OPACITY = 10 * Math.round(2 + 4 * (1 + Math.sin(opacityAnimationFactor)));
        }

        // UPDATE | START      
        gui.setOpacity(myOptions.OPACITY);
        gui.update();
        // UPDATE | END

        if (myOptions.ROTATION_X_AXIS) {
            mesh.rotation.x += 0.005 * myOptions.ROTATION_SPEED;
        }

        if (myOptions.ROTATION_Y_AXIS) {
            mesh.rotation.y -= 0.005 * myOptions.ROTATION_SPEED;
        }

        trackbarControl.update();

        stats.domElement.hidden = !myOptions.SHOW_STATS;
        if (myOptions.SHOW_STATS) {
            stats.update();
        }

        renderer.render(scene, camera);
    }

    function addOrUpdateRotatingText(scene, value) {
        "use strict";

        var oldRotationX = 0;
        var oldRotationY = 0;

        if (typeof mesh !== "undefined") {
            oldRotationX = mesh.rotation.x;
            oldRotationY = mesh.rotation.y;
            scene.remove(mesh);
        }

        var geometry = new THREE.TextGeometry(myOptions.RENDER_TEXT, {
                    height: myOptions.FONT_SIZE / 10,
                    size: myOptions.FONT_SIZE,
                    font: myOptions.FONT_NAME,
                    bevelSize: 1.5,
                    bevelThickness: 1.2,
                    bevelSegments: 4,
                    bevelEnabled: true
        });
        var material = new THREE.MeshPhongMaterial({
            color: 0xdddddd
        });
        mesh = new THREE.Mesh(geometry, material);

        mesh.rotation.x = oldRotationX;
        mesh.rotation.y = oldRotationY;

        geometry.computeBoundingBox();
        geometry.textWidth = geometry.boundingBox.max.x - geometry.boundingBox.min.x;
        mesh.translateX(-geometry.textWidth / 2);

        scene.add(mesh);
    }
</script>
</body>
</html>
